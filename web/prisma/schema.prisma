// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User model (extends Neon Auth user)
// Note: Auth data (email, password, sessions) lives in neon_auth schema
model User {
  id       String  @id // UUID from Neon Auth (no @default, synced from auth)
  name     String?
  image    String?
  approved Boolean @default(false) // Admin must approve before user can access data

  assignedChores ChoreAssignment[]
  completions    ChoreCompletion[]
  pushSubscriptions WebPushSubscription[]
  holidays       Holiday[]
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
}

model WebPushSubscription {
  id       String @id @default(uuid())

  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Web Push subscription endpoint (unique per browser profile/device).
  endpoint String @unique

  // Stored redundantly for convenience/debugging; canonical copy is in subscription.
  p256dh   String
  auth     String

  subscription Json
  userAgent    String?
  timezone     String?

  // Per-subscription idempotency keys for reminder delivery.
  lastMorningKey String?
  lastEveningKey String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

// Chore definition (the pool of tasks)
// Note: All chores are shared across the deployment (single household model)
model Chore {
  id          String    @id @default(uuid())
  title       String
  description String?
  frequency   Frequency // DAILY, WEEKLY, BIWEEKLY, MONTHLY, BIMONTHLY, SEMIANNUAL, YEARLY

  // For WEEKLY chores only: optional pinned weekday to auto-plan onto the daily schedule.
  // Stored as Monday-first index: 0=Mon .. 6=Sun.
  weeklyAutoPlanDay Int?

  // For BIWEEKLY chores only: optional pinned weekday to auto-plan onto the daily schedule.
  // Stored as Monday-first index: 0=Mon .. 6=Sun.
  //
  // biweeklyAutoPlanAnchor defines the first occurrence (start-of-day UTC) that should be
  // scheduled; subsequent occurrences are every 14 days.
  biweeklyAutoPlanDay    Int?
  biweeklyAutoPlanAnchor DateTime?

  assignments ChoreAssignment[]
  schedules   Schedule[]
  completions ChoreCompletion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([frequency])
}

// Assignment of chore to a user
model ChoreAssignment {
  id      String @id @default(uuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  choreId String
  chore   Chore  @relation(fields: [choreId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, choreId])
  @@index([choreId])
}

// Scheduled instance (slot-based system)
model Schedule {
  id      String @id @default(uuid())
  choreId String
  chore   Chore  @relation(fields: [choreId], references: [id], onDelete: Cascade)

  scheduledFor DateTime // When this task should be done
  slotType     Frequency // What kind of slot (WEEKLY, MONTHLY, etc)
  suggested    Boolean   @default(true) // Was this auto-suggested or manually selected
  hidden       Boolean   @default(false) // Hidden from views; used to "remove" auto-generated schedules

  completion ChoreCompletion?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([choreId, scheduledFor])
  @@index([hidden, scheduledFor])
  @@index([slotType, scheduledFor])
}

// Completion record
model ChoreCompletion {
  id      String @id @default(uuid())
  choreId String
  chore   Chore  @relation(fields: [choreId], references: [id], onDelete: Cascade)

  scheduleId String?   @unique
  schedule   Schedule? @relation(fields: [scheduleId], references: [id], onDelete: SetNull)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  completedAt DateTime @default(now())
  notes       String?

  @@index([userId, completedAt])
  @@index([choreId, completedAt])
}

model Holiday {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  startDate DateTime // UTC midnight, inclusive
  endDate   DateTime // UTC midnight, inclusive
  label     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, startDate, endDate])
  @@index([startDate, endDate])
}

enum Frequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  BIMONTHLY
  SEMIANNUAL
  YEARLY
}
